{
  "solution0": "const solution0 = (number: number, power: number) => {\r\n  return Math.pow(number, power);\r\n};",
  "solution1": "const solution1 = (string: string, shiftBy: number) => {\r\n  const letters = 'abcdefghijklmnopqrstuvwxyz'.split('');\r\n\r\n  const splitString = string.split('');\r\n\r\n  const shiftedString = splitString.map((char) => {\r\n    const letterIdx = letters.findIndex((letter) => {\r\n      return letter === char;\r\n    });\r\n\r\n    if (letterIdx === -1) {\r\n      return char;\r\n    }\r\n\r\n    //wrapping around the letters arr\r\n    if (letterIdx + shiftBy >= letters.length) {\r\n      return letters[letterIdx + shiftBy - letters.length];\r\n    }\r\n\r\n    return letters[letterIdx + shiftBy];\r\n  });\r\n\r\n  return shiftedString.join('');\r\n};\r\n",
  "solution2": "const solution2 = (text: string) => {\r\n  const counts: { [string: string]: number } = {};\r\n\r\n  text.split('').forEach((el: string) => {\r\n    if (!Object.keys(counts).includes(el)) {\r\n      counts[el] = 1;\r\n    } else {\r\n      counts[el] += 1;\r\n    }\r\n  });\r\n\r\n  Object.keys(counts).forEach((key) => {\r\n    if (counts[key] > 1) {\r\n      delete counts[key];\r\n    }\r\n  });\r\n\r\n  return Object.keys(counts).join('');\r\n};",
  "solution3": "const solution3 = (text: string) => {\r\n  const matches = text.match(/[a-z][A-Z]{3}([a-z])[A-Z]{3}[a-z]/g);\r\n\r\n  const letters = matches?.map((match: string) => {\r\n    return match[4];\r\n  });\r\n\r\n  if (!matches) {\r\n    return '';\r\n  }\r\n\r\n  return letters?.join('') as string;\r\n};",
  "solution4": "//backend part, as nextjs api route\r\n\r\nconst handler = async (req: NextApiRequest, res: NextApiResponse) => {\r\n  const url = `http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing=${req.query.nothing}`;\r\n\r\n  const regex = /nothing is [0-9]+/g;\r\n\r\n  const request = http.get(url, (resp) => {\r\n    let data = '';\r\n    resp.on('data', (chunk) => {\r\n      data += chunk;\r\n    });\r\n    resp.on('end', () => {\r\n      const matches = data.match(regex);\r\n      if (matches) {\r\n        res.status(200).send({ matches: matches[0].substring(11) });\r\n      } else if (data.includes('Yes')) {\r\n        res.status(200).send({ halfWay: 'yes' });\r\n      } else {\r\n        res.status(200).send({ finished: data });\r\n      }\r\n    });\r\n  });\r\n  request.on('error', (err) => {\r\n    console.log(err);\r\n  });\r\n};\"\r\n\r\n//frontend part\r\n\r\nconst solution4 = async (nothing: number) => {\r\n  fetch(`api/solutions/forSolution4?nothing=${nothing}`)\r\n    .then((data) => {\r\n      return data.json();\r\n    })\r\n    .then((data) => {\r\n      if (data.matches) {\r\n        solution4(data.matches);\r\n      }\r\n      if (data.halfWay) {\r\n        solution4(16044 / 2);\r\n      }\r\n      if (data.finished) {\r\n        return data.finished;\r\n      }\r\n    });\r\n};",
  "solution5": "const solution5 = () => {\r\n  //sorry, there is nothing in here\r\n};\r\n",
  "solution6": "//We need to use node again, so backend first:\r\n\r\nimport { NextApiRequest, NextApiResponse } from 'next';\r\nimport StreamZip from 'node-stream-zip';\r\n\r\nconst handler = async (req: NextApiRequest, res: NextApiResponse) => {\r\n  const zip = new StreamZip.async({\r\n    file: 'D:\\\\GitRepos\\\\pythonchallenge_js\\\\materials\\\\challenge6\\\\channel.zip',\r\n  });\r\n\r\n  const entries = await zip.entries();\r\n  const initialBuffer = await zip.entryData('94191.txt');\r\n  let fileText = initialBuffer.toString();\r\n  \r\n  const comments = [];\r\n\r\n  while (fileText.match(/[0-9]+/g)) {\r\n    const identifier = fileText.match(/[0-9]+/g);\r\n    const newBuffer = await zip.entryData(`${identifier}.txt`);\r\n    if (!identifier) {\r\n      fileText = newBuffer.toString();\r\n      comments.push(entries[`${identifier}.txt`].comment);\r\n      break;\r\n    }\r\n    fileText = newBuffer.toString();\r\n    comments.push(entries[`${identifier}.txt`].comment);\r\n  }\r\n\r\n  return res.status(200).json({ comments: comments });\r\n};\r\n\r\n//And the frontend portion, that just prints to the console\r\nconst solution6 = () => {\r\n  fetch('./api/solutions/forSolution6')\r\n    .then((data) => {\r\n      return data.json();\r\n    })\r\n    .then((data) => {\r\n      console.log(data.comments.join());\r\n    });\r\n};\r\n",
  "solution7": "const Solution7 = () => {\r\n  const canvasRef = useRef<HTMLCanvasElement>(null);\r\n\r\n  useEffect(() => {\r\n    const canvas = canvasRef.current;\r\n    const ctx = canvas?.getContext('2d');\r\n    const img = new Image();\r\n    img.src = '/oxygen.png';\r\n    img.onload = () => {\r\n      if (canvas) {\r\n        canvas.width = img.width;\r\n        canvas.height = img.height;\r\n      }\r\n      ctx?.drawImage(img, 0, 0, img.width, img.height);\r\n    };\r\n  }, []);\r\n\r\n  const getImageData = () => {\r\n    const canvas = canvasRef.current;\r\n    const ctx = canvas?.getContext('2d');\r\n\r\n    const pixels = [];\r\n\r\n    let i = 0;\r\n\r\n    while (i < 629) {\r\n      const pixelData = ctx?.getImageData(i, 92 / 2, 1, 1);\r\n      pixels.push(pixelData?.data[0]);\r\n      i += 7;\r\n    }\r\n\r\n    //See console for the decoded message and the solution\r\n    const decoded = pixels\r\n      .map((num) => {\r\n        return String.fromCharCode(num as number);\r\n      })\r\n      .join('');\r\n    console.log(decoded);\r\n\r\n    const matching = decoded.match(/(?<=\\[)(.*?)(?=\\])/);\r\n\r\n    if (matching) {\r\n      const finalString = matching[0]\r\n        .split(',')\r\n        .map((char) => {\r\n          return String.fromCharCode(+char);\r\n        })\r\n        .join('');\r\n\r\n      console.log(finalString);\r\n    }\r\n  };\r\n\r\n  return (\r\n    <div className=\"flex flex-col items-center\">\r\n      <canvas className=\"mb-3\" ref={canvasRef} />\r\n      <Button onClick={() => getImageData()}>Try it!</Button>\r\n    </div>\r\n  );\r\n};",
  "solution8": "//first up, the backend part\r\nimport compressjs from 'compressjs';\r\nimport { NextApiRequest, NextApiResponse } from 'next';\r\n\r\nconst forSolution8 = async (req: NextApiRequest, res: NextApiResponse) => {\r\n  const un =\r\n    'BZh91AY&SYA\\xaf\\x82\\r\\x00\\x00\\x01\\x01\\x80\\x02\\xc0\\x02\\x00\r\n \\x00!\\x9ah3M\\x07<]\\xc9\\x14\\xe1BA\\x06\\xbe\\x084';\r\n  const pw =\r\n    'BZh91AY&SY\\x94$|\\x0e\\x00\\x00\\x00\\x81\\x00\\x03$ \\x00!\\x9ah3M\\x13<]\r\n\\xc9\\x14\\xe1BBP\\x91\\xf08';\r\n\r\n  const algorithm = compressjs.Bzip2;\r\n\r\n  const unBuffer = Buffer.from(un, 'ascii');\r\n  const pwBuffer = Buffer.from(pw, 'ascii');\r\n\r\n  //decompress and convert buffer to utf-8 string\r\n  const decompressedUn = Buffer.from(\r\n    algorithm.decompressFile(unBuffer)\r\n  ).toString('utf-8');\r\n  const decompressedPw = Buffer.from(\r\n    algorithm.decompressFile(pwBuffer)\r\n  ).toString('utf-8');\r\n\r\n  return res.status(200).json({ decompressedUn, decompressedPw });\r\n};\r\n\r\nexport default forSolution8;\r\n\r\n//And frontent, again just logging the result to the console\r\nconst solution8 = () => {\r\n  fetch('api/solutions/forSolution8')\r\n    .then((resp) => {\r\n      return resp.json();\r\n    })\r\n    .then((data) => {\r\n      console.log(data);\r\n    });\r\n};\r\n\r\nexport default solution8;\r\n\r\n",
  "solution9": "import { useEffect, useRef } from 'react';\r\nimport first from './first';\r\n//first is array of numbers: [146, 399, 163, 403, 170, 393, 169, etc...]\r\n\r\nconst Solution9 = () => {\r\n  const canvasRef = useRef<HTMLCanvasElement>(null);\r\n\r\n  useEffect(() => {\r\n    const canvas = canvasRef.current;\r\n    const ctx = canvas?.getContext('2d');\r\n\r\n    ctx?.beginPath();\r\n\r\n    for (let i = 0; i < first.length; i += 2) {\r\n      ctx?.lineTo(first[i], first[i + 1]);\r\n      ctx?.stroke();\r\n    }\r\n    ctx?.fill();\r\n  }, []);\r\n\r\n  return (\r\n    <div>\r\n      <canvas ref={canvasRef} height={500} width={500} />\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Solution9;\r\n",
  "solution10": "const solution10 = () => {\r\n  //finds next number in the sequence\r\n  const findNextTerm = (str: string) => {\r\n    const matches = str.match(/(.)\\1*/g);\r\n    const nextTerm: string[] = [];\r\n    matches?.forEach((match) => {\r\n      nextTerm.push(`${match.length}${match[0]}`);\r\n    });\r\n\r\n    return nextTerm.join('');\r\n  };\r\n\r\n  //do 30 iterations of finding next term\r\n  let currentTerm = '1';\r\n  for (let i = 0; i < 30; i++) {\r\n    const nextTerm = findNextTerm(currentTerm);\r\n    currentTerm = nextTerm;\r\n  }\r\n\r\n  //logs 5808\r\n  console.log(currentTerm.length);\r\n};",
  "solution11": "import { useEffect, useRef } from 'react';\r\n\r\nconst Solution11 = () => {\r\n  const sourceCanvasRef = useRef<HTMLCanvasElement>(null);\r\n  const evenCanvasRef = useRef<HTMLCanvasElement>(null);\r\n  const oddCanvasRef = useRef<HTMLCanvasElement>(null);\r\n\r\n  useEffect(() => {\r\n    const sourceCanvas = sourceCanvasRef.current;\r\n    const sourceCtx = sourceCanvas?.getContext('2d');\r\n\r\n    const evenCanvas = evenCanvasRef.current;\r\n\r\n    const oddCanvas = oddCanvasRef.current;\r\n\r\n    const img = new Image();\r\n    img.src = './cave.jpg';\r\n\r\n    //Stop typescript from complaining\r\n    if (!sourceCanvas || !evenCanvas || !oddCanvas) return;\r\n\r\n    img.onload = () => {\r\n      sourceCanvas.height = img.height;\r\n      evenCanvas.height = oddCanvas.height = img.height / 2;\r\n\r\n      sourceCanvas.width = img.width;\r\n      evenCanvas.width = oddCanvas.width = img.width / 2;\r\n\r\n      sourceCtx?.drawImage(img, 0, 0);\r\n      splitImages();\r\n    };\r\n  });\r\n\r\n  const splitImages = () => {\r\n    const sourceCanvas = sourceCanvasRef.current;\r\n    const sourceCtx = sourceCanvas?.getContext('2d');\r\n\r\n    const evenCanvas = evenCanvasRef.current;\r\n    const evenCtx = evenCanvas?.getContext('2d');\r\n\r\n    const oddCanvas = oddCanvasRef.current;\r\n    const oddCtx = oddCanvas?.getContext('2d');\r\n\r\n    //stop TS from complaining\r\n    if (!sourceCanvas || !evenCanvas || !sourceCtx || !oddCanvas) {\r\n      return;\r\n    }\r\n\r\n    for (let i = 0; i < sourceCanvas?.width; i++) {\r\n      for (let j = 0; j < sourceCanvas.height; j++) {\r\n        const pixelData = sourceCtx.getImageData(i, j, 1, 1);\r\n        if (i % 2 === 0) {\r\n          evenCtx?.putImageData(pixelData, i / 2, j / 2);\r\n        } else {\r\n          oddCtx?.putImageData(pixelData, i / 2, j / 2);\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  return (\r\n    <div>\r\n      <canvas ref={sourceCanvasRef} id=\"1\"></canvas>\r\n      <canvas ref={evenCanvasRef} id=\"2\"></canvas>\r\n      <canvas ref={oddCanvasRef} id=\"3\"></canvas>\r\n    </div>\r\n  );\r\n};",
  "solution12": "import path from 'path';\r\nimport fs from 'fs';\r\n\r\nconst handler = async () => {\r\n  const filepath = path.resolve('./public/solution12');\r\n\r\n  const source = fs.readFileSync(`${filepath}/evil2.gfx`);\r\n\r\n  //create array for \"piles\" of bytes\r\n  const buffers: number[][] = [];\r\n\r\n  //create piles\r\n  for (let i = 0; i < 5; i++) {\r\n    buffers.push([]);\r\n  }\r\n\r\n  //deal bytes into plies, one by one, like cards\r\n  for (let i = 0; i < source.length; i += 5) {\r\n    for (let j = 0; j < 5; j++) {\r\n      buffers[j].push(source[i + j]);\r\n    }\r\n  }\r\n\r\n  //create files from buffers\r\n  for (let i = 0; i < 5; i++) {\r\n    const file = fs.openSync(`${filepath}/${i}.jpg`, 'w');\r\n\r\n    const buffer = Buffer.from(buffers[i]);\r\n\r\n    fs.writeFileSync(file, buffer);\r\n  }\r\n};",
  "solution13": "import { NextApiRequest, NextApiResponse } from 'next';\r\nimport xmlrpc from 'davexmlrpc';\r\n\r\nconst handler = (req: NextApiRequest, res: NextApiResponse) => {\r\n  const url = 'http://www.pythonchallenge.com/pc/phonebook.php';\r\n  const format = 'xml';\r\n\r\n  //check for available methods\r\n  xmlrpc.client(\r\n    url,\r\n    'system.listMethods',\r\n    [],\r\n    format,\r\n    (err: any, data: any) => {\r\n      if (err) {\r\n        console.log(err);\r\n        return;\r\n      }\r\n\r\n      console.log(data);\r\n    }\r\n  );\r\n\r\n  //find out what the method does, requires and returns\r\n  xmlrpc.client(\r\n    url,\r\n    'system.methodHelp',\r\n    ['phone'],\r\n    format,\r\n    (err: any, data: any) => {\r\n      if (err) {\r\n        console.log(err);\r\n        return;\r\n      }\r\n\r\n      console.log(data);\r\n    }\r\n  );\r\n\r\n  xmlrpc.client(\r\n    url,\r\n    'system.methodSignature',\r\n    ['phone'],\r\n    format,\r\n    (err: any, data: any) => {\r\n      if (err) {\r\n        console.log(err);\r\n        return;\r\n      }\r\n\r\n      console.log(data);\r\n    }\r\n  );\r\n\r\n  //call the phone method for the solution\r\n  xmlrpc.client(url, 'phone', ['Bert'], format, (err: any, data: any) => {\r\n    if (err) {\r\n      console.log(err);\r\n      return;\r\n    }\r\n\r\n    console.log(data);\r\n  });\r\n\r\n  return res.status(200);",
  "solution14": "import { useEffect, useRef } from 'react';\r\n\r\nconst Solution14 = () => {\r\n  const srcCanvasRev = useRef<HTMLCanvasElement>(null);\r\n  const outCanvasRev = useRef<HTMLCanvasElement>(null);\r\n\r\n  //load the source image into srcCanvas\r\n  useEffect(() => {\r\n    const srcCanvas = srcCanvasRev.current;\r\n    const srcCtx = srcCanvas?.getContext('2d');\r\n\r\n    if (!srcCtx || !srcCanvas) {\r\n      return;\r\n    }\r\n\r\n    const img = new Image();\r\n    img.src = './wire.png';\r\n\r\n    img.onload = () => {\r\n      srcCanvas.height = img.height;\r\n      srcCanvas.width = img.width;\r\n      srcCtx.drawImage(img, 0, 0);\r\n    };\r\n  });\r\n\r\n  //Create a spiral from srcCanvas to outCanvas\r\n  const createSpiral = () => {\r\n    const outCtx = outCanvasRev.current?.getContext('2d');\r\n    const srcCtx = srcCanvasRev.current?.getContext('2d');\r\n\r\n    //Stop TS from complaining\r\n    if (!outCtx || !srcCtx) return;\r\n\r\n    const delta = [\r\n      [1, 0], //Go right\r\n      [0, 1], //Go down\r\n      [-1, 0], // Go left\r\n      [0, -1], // Go up\r\n    ];\r\n\r\n    let x = -1; //start at -1 to put first pixel at 0:0 in first iteration\r\n    let y = 0;\r\n    let idx = 0;\r\n\r\n    let d = 200; //200 not 100, since 100 would just fill half a spiral\r\n\r\n    while (d / 2 > 0) {\r\n      //go right, down, left, up and repeat\r\n      for (const v of delta) {\r\n        const steps = Math.floor(d / 2);\r\n        for (let i = 0; i < steps; i++) {\r\n          //move in correct direction\r\n          x = x + v[0];\r\n          y = y + v[1];\r\n\r\n          //get pixel data and put it in outCanvas\r\n          const pixel = srcCtx.getImageData(idx, 0, 1, 1);\r\n          outCtx.putImageData(pixel, x, y);\r\n          idx++;\r\n        }\r\n        d--;\r\n      }\r\n    }\r\n  };\r\n\r\n  return (\r\n    <div>\r\n      <canvas ref={srcCanvasRev}></canvas>\r\n      <canvas ref={outCanvasRev} height={100} width={100}></canvas>\r\n    </div>\r\n  );\r\n};",
  "solution15": "const solution15 = () => {\r\n  //we know the year is between 1006 and 1996\r\n  //first leap year in this range is 1016.\r\n\r\n  //knowing that, loop over the range, checking for years that have Jan 26th as monday\r\n\r\n  const mondays = [];\r\n\r\n  //i+=20 since leap years ending in 6 come every 20 years\r\n  for (let i = 1036; i < 1996; i += 20) {\r\n    if (new Date(`${i}-1-26`).getDay() === 1) {\r\n      mondays.push(i);\r\n    }\r\n  }\r\n\r\n  //log second to last monday, aka \"second youngest\"\r\n  console.log(mondays[mondays.length - 2]);\r\n};\r\n\r\nexport default solution15;",
  "solution16": "import { chunk } from 'lodash';\r\nimport { useEffect, useRef } from 'react';\r\nimport Button from '../../components/UIElements/Button';\r\n\r\nconst Solution16 = () => {\r\n  const srcCanvasRef = useRef<HTMLCanvasElement>(null);\r\n  const outCanvasRef = useRef<HTMLCanvasElement>(null);\r\n\r\n  //load the source image into srcCanvas\r\n  useEffect(() => {\r\n    const srcCanvas = srcCanvasRef.current;\r\n    const srcCtx = srcCanvas?.getContext('2d');\r\n\r\n    const outCanvas = outCanvasRef.current;\r\n\r\n    if (!srcCtx || !srcCanvas || !outCanvas) {\r\n      return;\r\n    }\r\n\r\n    const img = new Image();\r\n    img.src = './mozart.jpg';\r\n\r\n    img.onload = () => {\r\n      srcCanvas.height = img.height;\r\n      srcCanvas.width = img.width;\r\n\r\n      outCanvas.height = img.height;\r\n      outCanvas.width = img.width;\r\n      srcCtx.drawImage(img, 0, 0);\r\n    };\r\n  }, []);\r\n\r\n  const shiftRows = () => {\r\n    const srcCanvas = srcCanvasRef.current;\r\n    const srcCtx = srcCanvas?.getContext('2d');\r\n\r\n    const outCanvas = outCanvasRef.current;\r\n    const outCtx = outCanvas?.getContext('2d');\r\n\r\n    if (!srcCanvas || !srcCtx || !outCanvas || !outCtx) return;\r\n\r\n    const imgData = srcCtx.getImageData(\r\n      0,\r\n      0,\r\n      srcCanvas.width,\r\n      srcCanvas.height\r\n    );\r\n\r\n    //split image data into separate lines\r\n    const lines = chunk(imgData.data, srcCanvas.width * 4);\r\n\r\n    console.log(lines);\r\n\r\n    const pinkStripsIdxs: number[] = [];\r\n\r\n    //find the location of pink strip in each line\r\n    //what we are lookin for is (255,0,255) in rgb, a color called \"fuchsia\"\r\n    lines.forEach((line) => {\r\n      for (let i = 0; i < srcCanvas.width * 4; i++) {\r\n        if (line[i] === 255) {\r\n          if (line[i + 1] === 0 && line[i + 2] === 255) {\r\n            return pinkStripsIdxs.push(i);\r\n          }\r\n        }\r\n      }\r\n    });\r\n\r\n    //shift each pink strip to the beginning of the line\r\n\r\n    const shifted = lines.map((line, idx) => {\r\n      const toShift = line.slice(0, pinkStripsIdxs[idx]);\r\n      const remainder = line.slice(pinkStripsIdxs[idx]);\r\n\r\n      const afterShift = [...remainder, ...toShift];\r\n      return afterShift;\r\n    });\r\n\r\n    //join all lines into single array\r\n    const joined = shifted.flat(1);\r\n\r\n    //paint the new lines\r\n    const buffer = new Uint8ClampedArray(joined);\r\n    const newImageData = new ImageData(\r\n      buffer,\r\n      outCanvas.width,\r\n      outCanvas.height\r\n    );\r\n    outCtx?.putImageData(newImageData, 0, 0);\r\n  };\r\n\r\n  return (\r\n    <div>\r\n      <canvas ref={srcCanvasRef}></canvas>\r\n      <canvas ref={outCanvasRef}></canvas>\r\n      <Button onClick={() => shiftRows()}>Transform</Button>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Solution16;\r\n"
}
